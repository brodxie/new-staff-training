## 4.对象与类 ##

- **概念**

OOP：面向对象程序设计  
类：构造对象的模板或蓝图  
封装：也称数据隐藏，将数据和行为组合在一个包中。  
类之间的关系：继承、接口实现、依赖、聚合、关联、直接关联


- **构造器**

与类同名；  
每个类可有一个以上的构造器；  
参数可有0个、1个或1个以上；  
无返回值。

- **参数**

隐式参数：方法名前。  
显式参数：方法声明中。  
每个方法中，this表示隐式参数。

- **方法**

每个类只有一个static域，该域属于类，不属于任何独立的对象。

重载：方法名相同，参数不同。

仅当类没有提供任何构造器时，系统才会提供一个默认的构造器。

初始化数据域的方法：  
在构造器中设置值；  
在声明中赋值；  
初始化块。

- **注释**

注释标记

@param 变量、@return 返回、@throws 异常、@author 姓名、@version 版本、@since 始于、@deprecated 取代、@see 引用

- **类的设计技巧**

1）保证数据私有；  
2）对数据进行初始化；  
3）不要在类中有过多基本类型；  
4）并非所有域都需要独立的域访问器和域更改器；  
5）将职责过多的类进行分解；  
6）类名和方法名要能够体现其职责；  
7）优先使用不可变的类。

## 5.继承 ##


- **相关概念**

this用途：引用隐式参数，调用该类其他的构造器。
super用途：调用超类的方法或构造器。
阻止继承：final类和方法

- **类型转换**

只能在继承层次内进行类型转换；  
在将超类转换成子类之前，应该使用instanceof进行检查。

- **抽象类**

充当占位的角色，具体在子类中实现；  
不能被实例化。

控制可见性：  
private，仅对本类可见  
public，对所有类可见  
protected，对本包和所有子类可见  
default，对本包可见

equals方法的特性：  
自反性  
对称性  
传递性  
一致性  
对于任意非空引用x，x.equals(null)应该返回false。

- **数组**

java.util.ArrayList<E> 1.2
`int size()`: 返回存储在数组列表中的当前元素的数量。  
`void ensureCapacity(int capacity)`: 确保数组列表在不重新分配存储空间的情况下就能够保存给定数量的元素。  
`void trimToSize()`: 将数组列表的存储容量削减到当前尺寸。  
`E remove(int index)`: 删除一个元素，并将后面的元素向前移动。被删除的元素由返回值返回。

`@SuppressWarnings("unchecked")`: 表示变量能够接受类型转换。

- **对象包装器与自动装箱**

对象包装器类：Integer、Long、Float、Double、Short、Byte、Character、Void、Boolean（前6个派生于公共的超类Number）。  
对象的包装类不可变，且被final修饰，即不可定义其子类。

备注：Java的方法都是值传递，可使用org.omg.CORBA包中定义的持有者(holder)类型编写一个修改数值参数值的方法，包括IntHolder、BooleanHolder等。每个持有者类型都包含一个公有(!)域值，通过它可以访问存储在其中的值。  
    public static void triple(IntHolder x) {
      x.value = 3 * x.value;
    }

- **方法**

参数可变的方法：省略号...是Java代码的一部分，表示方法可以接收任意数量的对象（除fmt参数之外）。
例如，Object...类似于Object[]。

枚举类：  
例如：`public enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE};`    
在比较两个枚举类型的值时，不要调用equals，直接使用“==”。  
int original():返回枚举常量在enum声明中的位置，从0开始计数。  
int compareTo(E other): 如果枚举常量在other之前，返回负值；如果this==other，返回0；否则，返回正值。枚举常量出现次序在enum声明中给出。 

- **反射**

反射：能够分析类能力的程序。   

作用：   
在运行时分析类的能力；  
在运行时查看对象；  
实现通用的数组操作代码；  
利用Method对象。

虚拟机为每一个类型管理一个Class对象。可利用==运算符实现两个类对象比较的操作。

异常的两种类型：未检查异常、已检查异常。

- **继承的设计技巧**

将公共操作或域放在超类；  
不要使用受保护的域；  
使用继承实现“is-a”关系；  
除非所有继承的方法都有意义，否则不要使用继承；  
在覆盖方法时，不要改变预期的行为；  
使用多态，而非类型信息；  
不要过多地使用反射。

## 6.接口、lambda表达式与内部类 ##

- **接口**

类实现接口的步骤：  
1）将类声明为实现给定的接口；  
2）对接口中的所有方法进行定义。  

关键字：implements

特性：  
不能用new实例化一个接口；  
可声明接口的变量；  
接口变量必须引用实现了接口的类对象；  
允许多条从具有较高通用性的接口到较高专用性的接口链；  
接口中不能包含实例或静态方法，却可以包含常量。


默认方法：  
可为接口提供一个默认实现，但必须用default标记。

解决默认方法冲突：  
如果一个接口中将一个方法定义为默认方法，又在超类或另一个接口中定义了同样的方法。Java语言的解决规则：  
① 超类有限；  
② 接口冲突。通过覆盖方法的方式解决冲突。

- **接口示例**

回调：指出某个特定事件发生时应该采取的动作。