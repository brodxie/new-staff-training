————————————————————————————————  
（上接javaNotes_20190710）



**抽象类与接口**

区别：

① 抽象类可以有构造方法，接口不可以；

② 抽象类可有普通成员变量，接口不可以；

③ 抽象类可有静态方法，接口不可以；

④ 一个类可实现多个接口，只能继承一个抽象类；

⑤ 接口可被多重实现，抽象类只能被单一继承；

⑥ 如果抽象类实现接口，可以把方法映射到抽象类作为方法而不必实现，而在抽象类的子类中实现接口中方法。

相同点：

都可被继承；不能被实例化；可包含方法声明；派生类必须实现未实现的方法。



**Comparator接口**

String.compareTo方法可以按字典顺序比较字符串。



**对象克隆**

clone方法：初始状态不变，之后copy、original各自有不同的状态。

浅拷贝与深拷贝：

​       默认的克隆操作是“浅拷贝”，并没有克隆对象中引用的其他对象。如果原对象和浅克隆对象共享的子对象是不可变的（如String），那么这种共享是安全的。或者在对象的生命期中，子对象一直包含不变的常量，没有变更器方法会改变它，也没有方法会生成它的引用，这种情况同样是安全的。

​		深拷贝实现要求：

​		1) 类需要实现Cloneable接口；

​		2) 重新定义clone方法，并指定public访问修饰符。



**lambda表达式**

1）表达式形式：参数，箭头（->），表达式；

2）作用：如果代码要完成的计算无法放在一个表达式中，可以像写方法一样，放在{}中，并包含显式的return语句；

3）备注：无需指定lambda表达式的返回类型（可由上下文推导得出）。

4）函数式接口

​      概念：对于只有一个抽象方法的接口，需要接口的对象时，可提供一个lambda表达式。

<u>5）方法引用</u>

使用::操作符分隔方法名与对象或类名。主要有3种情况：

- `object::instanceMethod`
- `Class::staticMethod`
- `Class:instanceMethod`

前两种方法引用等价于提供方法参数的lambda表达式。

`System.out::println`等价于`x->System.out.println(x)`

`Math::pow`等价于`(x,y)->Math.pow(x,y)`

第三种情况的第1个参数会成为方法的目标。

`String::compareToIgnoreCase`等价于`(x,y)->x.compareToIgnoreCase(y)`



可以在方法引用种使用this参数。例如`this::equals`等同于`x->this.equals(x)`

`super::instanceMethod`使用this作为目标，调用给定方法的超类版本。

6）构造器引用

- 与方法引用类似，但方法名为new。例如，`Person::new`是Person构造器的引用，具体构造器取决于上下文。
- 可用数组建立构造器引用。如`int[]::new`是一个构造器引用，其参数为数组的长度，等价于`x->new int[x]`。
- 数组构造器引用可克服Java语言无法构造泛型类型T的数组。如`Person[] people = stream.toArray(Person[]::new)`。



**内部类**

概念：定义在另一个类中的类。

原因：

- 访问类定义所在作用域中的数据，包括私有数据；
- 可对同一个包中的其他类隐藏起来；
- 想定义一个回调函数不想编写大量代码时，可使用匿名内部类。

局部内部类：

可对外部世界完全隐藏起来。



**代理**

可在运行时创建一个实现了一组给定接口的新类。



## 7 异常、断言和日志

### 7.1 处理错误

异常处理的任务：将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。

异常类（Error、Exception）都派生于Throwable类。

Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。

Exception类包含RuntimeException和IOException。



非受查（unchecked）异常：派生于Error类或RuntimeException类的所有异常。

受查异常：与非受查异常相反的所有其他异常。

### 7.2 捕获异常

在一个try语句块中可捕获多个异常类型，并对不同类型的异常做不同处理。

在Java SE7中，同一个catch子句中可以捕获多个异常类型。



堆栈轨迹：一个方法调用过程的列表，包含程序执行过程中方法调用的特定位置。

- 调用Throwable类的printStackTrace方法访问堆栈轨迹的文本描述信息。
- 使用getStackTrace方法，得到StackTraceElement对象的一个数组。
- 静态的Thread.getAllStackTrace方法，可以产生所有线程的堆栈轨迹。



### 7.3 使用异常机制的技巧

- 不可替代简单的测试

- 不可过分细化异常

- 利用异常层次结构

- 不要压制异常

- 早抛出，晚捕获

	

### 7.4 使用断言

断言形式：

① assert 条件；

② assert 条件：表达式；

两种形式都会对条件进行检查，若结果为false，抛出AssertionError异常。第二种形式中，表达式被传入AssertionError的构造器，并转换成一个消息字符串。



断言启用/禁用：

① 在运行程序时用-enableassertions或-ea选项启用：

java -enableassertions myApp

② 在某个类或整个包中使用断言：

java -ea:MyClass -ea:com.mycompany.mylib... MyApp

③ 用选项-disableassertions或-da禁用某个特定类或包的断言：

java -ea:... -da:MyClass MyApp



在启用或禁用断言时不必重新编译程序。启用/禁用断言是类加载器的功能。断言被禁用时，类加载器将跳过断言代码。因此，不会降低程序的运行速度。



Java中的错误处理机制：

① 抛出异常

② 日志

③ 断言



注意：

① 断言失败是致命、不可恢复的错误；

② 断言检查只用于开发和测试阶段。



### 7.5 记录日志

基本日志：可使用全局日志记录器并调用其info方法。

高级日志：

日志记录级别：SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST



## 8 泛型程序设计

基础概念：

- 泛型程序设计意味着编写的代码可以被不同类型的对象所重用。

- 在Java SE7及之后版本中，构造函数可省略泛型类型：`ArrayList<String> files = new ArrayList<>();`



定义简单的泛型类

- 一个泛型类就是具有一个或多个类型变量的类。
- 在Java库中，使用变量E表示集合的元素类型，K和V分别表示表的关键字与值的类型。T（需要时还可以用临近的字母U和S）表示“任意类型”。
- 泛型类可看做普通类的工厂。



泛型方法

​       概念：带有类型参数的方法。